{"id":"oxid-1lw","title":"Refactor parse_hcl to extract parse_hcl_body","description":"The json_parser needs to feed a programmatically-built hcl::Body into the existing block parsing logic. Currently parse_hcl() takes a \u0026str and calls hcl::from_str() internally. Extract the body-iteration loop into a public parse_hcl_body(body: hcl::Body, file_path: \u0026Path) -\u003e Result\u003cWorkspaceConfig\u003e function.","design":"File: src/hcl/parser.rs. Split parse_hcl() into two functions: (1) parse_hcl() keeps the \u0026str signature, calls hcl::from_str(), then delegates to parse_hcl_body(). (2) parse_hcl_body() takes hcl::Body + file_path, contains all the existing block iteration logic (unchanged). Add .with_context() to the hcl::from_str() call for better error messages. Make parse_hcl_body pub(crate).","acceptance_criteria":"All existing cargo tests pass with zero changes. parse_hcl_body is public and callable from json_parser.rs. No logic changes to the body iteration — pure extraction refactor.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-17T17:14:12.784266+08:00","updated_at":"2026-02-17T18:39:57.818177+08:00","closed_at":"2026-02-17T18:39:57.818177+08:00","labels":["component:parser","phase:foundational","requirement:FR-002","spec:001-tf-json-parsing"],"dependencies":[{"issue_id":"oxid-1lw","depends_on_id":"oxid-4j7","type":"parent-child","created_at":"2026-02-17T17:14:12.785961+08:00","created_by":"daemon"}]}
{"id":"oxid-2cr","title":"Implement error context with filenames in json_parser.rs","description":"Ensure all error paths in parse_tf_json include the source filename using anyhow::Context. This is the implementation counterpart to the error tests.","design":"File: src/hcl/json_parser.rs. Ensure all error paths have .with_context():\n\n1. JSON parse error: serde_json::from_str(content).with_context(|| format\\!(\"Failed to parse JSON in {}\", file_path.display()))\n2. Root not object: anyhow::bail\\!(\"Expected JSON object at root of {}, got {}\", file_path.display(), type_description)\n3. Unknown block type: Log a tracing::warn\\! but don't error (match Terraform behavior of ignoring unknown keys)\n4. Block structure errors: .with_context(|| format\\!(\"Invalid block structure in {}\", file_path.display()))\n5. Label peeling errors: .with_context(|| format\\!(\"Expected object for block labels in {}\", file_path.display()))\n\nPattern: Follow existing parse_hcl error handling style from parser.rs (anyhow::Result with .context() chains).","acceptance_criteria":"Error tests (T011) all pass. Error messages always include the filename. JSON syntax errors report the serde_json error message. Structural errors are descriptive.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-17T17:27:50.773671+08:00","updated_at":"2026-02-17T19:24:11.479814+08:00","closed_at":"2026-02-17T19:24:11.479814+08:00","labels":["component:parser","phase:us3","requirement:FR-007","requirement:FR-008","spec:001-tf-json-parsing","story:US3"],"dependencies":[{"issue_id":"oxid-2cr","depends_on_id":"oxid-lab","type":"parent-child","created_at":"2026-02-17T17:27:50.775958+08:00","created_by":"daemon"},{"issue_id":"oxid-2cr","depends_on_id":"oxid-p4r","type":"blocks","created_at":"2026-02-17T17:27:58.791186+08:00","created_by":"daemon"}]}
{"id":"oxid-4j7","title":"Phase 1: Foundational - Parser Refactor","description":"Refactor parse_hcl() to extract parse_hcl_body() as a prerequisite for all tf.json work. This is the critical path — no user story can begin until the existing parser exposes its body-iteration logic.","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-02-17T16:59:24.246117+08:00","updated_at":"2026-02-17T18:52:02.252965+08:00","closed_at":"2026-02-17T18:52:02.252965+08:00","labels":["phase:foundational","spec:001-tf-json-parsing"],"dependencies":[{"issue_id":"oxid-4j7","depends_on_id":"oxid-db0","type":"parent-child","created_at":"2026-02-17T16:59:24.247141+08:00","created_by":"daemon"}]}
{"id":"oxid-5jn","title":"Phase 2: US1 - Core tf.json Parsing (P1 MVP)","description":"Implement end-to-end tf.json parsing: file discovery, JSON→Body conversion, and integration with existing parser. Validated against 8 CDKTF fixtures. This phase alone delivers a working feature.","status":"closed","priority":1,"issue_type":"feature","created_at":"2026-02-17T16:59:24.41108+08:00","updated_at":"2026-02-17T19:03:42.634675+08:00","closed_at":"2026-02-17T19:03:42.634675+08:00","labels":["phase:us1","spec:001-tf-json-parsing","story:US1"],"dependencies":[{"issue_id":"oxid-5jn","depends_on_id":"oxid-db0","type":"parent-child","created_at":"2026-02-17T16:59:24.412433+08:00","created_by":"daemon"},{"issue_id":"oxid-5jn","depends_on_id":"oxid-4j7","type":"blocks","created_at":"2026-02-17T16:59:45.844257+08:00","created_by":"daemon"}]}
{"id":"oxid-6gz","title":"Create json_parser.rs module skeleton with parse_tf_json stub","description":"Create the new src/hcl/json_parser.rs module with the public parse_tf_json function signature. This must exist before tests can compile against it. Also register the module in src/hcl/mod.rs.","design":"File: src/hcl/json_parser.rs (NEW). Create: pub fn parse_tf_json(content: \u0026str, file_path: \u0026Path) -\u003e Result\u003cWorkspaceConfig\u003e that initially returns anyhow::bail!(\"tf.json parsing not yet implemented\"). Add pub mod json_parser; to src/hcl/mod.rs. Internal function stubs: json_to_body(), convert_block(), json_value_to_expression(), strip_comments(). Import serde_json::Value and hcl types.","acceptance_criteria":"Module compiles. parse_tf_json is callable from tests/ via oxid::hcl::json_parser::parse_tf_json. Returns a clear 'not implemented' error.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-17T17:21:26.583054+08:00","updated_at":"2026-02-17T18:58:07.611914+08:00","closed_at":"2026-02-17T18:58:07.611914+08:00","labels":["component:parser","phase:us1","requirement:FR-002","spec:001-tf-json-parsing","story:US1"],"dependencies":[{"issue_id":"oxid-6gz","depends_on_id":"oxid-5jn","type":"parent-child","created_at":"2026-02-17T17:21:26.584895+08:00","created_by":"daemon"}]}
{"id":"oxid-6kd","title":"Update file discovery for .tf.json in loader.rs and hcl/mod.rs","description":"Extend the config pipeline to discover and parse .tf.json files alongside .tf files. Two files need changes: mode detection in loader.rs and file scanning/dispatch in hcl/mod.rs.","design":"File 1: src/config/loader.rs\n  - has_tf_files() currently checks extension == 'tf'\n  - Add: also match filenames ending with '.tf.json'\n  - Note: .tf.json has extension 'json', so use file_name().to_str().ends_with('.tf.json')\n  - Both is_file() and is_dir() branches need updating\n\nFile 2: src/hcl/mod.rs\n  - parse_directory() currently filters for extension == 'tf' (line 18)\n  - Add second collection: tf_json_files filtered by filename ending '.tf.json'\n  - Sort tf_json_files alphabetically (FR-005)\n  - After parsing .tf files, loop through .tf.json files:\n    let content = std::fs::read_to_string(file)?;\n    let partial = json_parser::parse_tf_json(\u0026content, file)?;\n    merge_workspace(\u0026mut workspace, partial);\n  - Update error: only bail 'No .tf files found' if BOTH tf_files AND tf_json_files are empty\n  - Add tracing::debug!(\"Parsing tf.json file: {}\", file.display())\n\nOrder: .tf files first, then .tf.json files (matches Terraform behavior). Both sorted alphabetically within their group.","acceptance_criteria":"load_workspace() discovers and parses .tf.json files. Mode detection (has_tf_files) returns true for directories containing only .tf.json files. Directory with only .tf.json files does not error. Files are processed in alphabetical order.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-17T17:24:21.412951+08:00","updated_at":"2026-02-17T19:03:16.826473+08:00","closed_at":"2026-02-17T19:03:16.826473+08:00","labels":["component:config-loader","phase:us1","requirement:FR-001","requirement:FR-003","requirement:FR-004","requirement:FR-005","requirement:FR-006","spec:001-tf-json-parsing","story:US1"],"dependencies":[{"issue_id":"oxid-6kd","depends_on_id":"oxid-5jn","type":"parent-child","created_at":"2026-02-17T17:24:21.41655+08:00","created_by":"daemon"},{"issue_id":"oxid-6kd","depends_on_id":"oxid-7rb","type":"blocks","created_at":"2026-02-17T17:25:02.201919+08:00","created_by":"daemon"}]}
{"id":"oxid-7rb","title":"Implement json_to_body core converter in json_parser.rs","description":"The heart of the feature: convert a serde_json::Value representing a tf.json root object into an hcl::Body that the existing parse_hcl_body() can process. This implements the Terraform JSON Configuration Syntax mapping rules.","design":"File: src/hcl/json_parser.rs\n\n1. parse_tf_json(content, file_path):\n   - serde_json::from_str(content) with .with_context() for filename in errors\n   - Validate root is a JSON object\n   - Call json_to_body(\u0026root_object)\n   - Call parser::parse_hcl_body(body, file_path)\n\n2. json_to_body(root: \u0026serde_json::Map):\n   - Define block schema: HashMap\u003c\u0026str, usize\u003e mapping block type → label count\n     resource:2, data:2, provider:1, variable:1, output:1, module:1, terraform:0, locals:0\n   - For each key in root object:\n     - Skip '//' keys (FR-010)\n     - Look up in schema to get label count\n     - Call convert_block(block_type, label_count, value) for each\n   - Return Body::builder().add_block(...).build()\n\n3. convert_block(block_type, labels_remaining, value):\n   - If labels_remaining \u003e 0:\n     - value must be JSON object\n     - For each key in object: key becomes next label, recurse with labels_remaining-1\n     - If value is array: each element is a separate block instance\n   - If labels_remaining == 0:\n     - value is the block body\n     - Convert each JSON key/value pair to Attribute using json_value_to_expression()\n     - Handle nested blocks (objects/arrays that are blocks, not attributes)\n   - Special case for 'locals': each key is an attribute with expression value\n\n4. json_value_to_expression(value: \u0026serde_json::Value):\n   - Use hcl::to_expression(value) as the primary conversion\n   - This handles String→Expression::String, Number→Expression::Number, etc.\n   - Template parsing (detecting ${...}) is handled downstream by hcl_expr_to_expression in parser.rs\n\n5. strip_comments(obj: \u0026mut serde_json::Map):\n   - Remove all keys named '//' from the map\n   - Recurse into nested objects\n\nReference: data-model.md for block-to-JSON mapping table, research.md section 2 for label peeling algorithm.","acceptance_criteria":"Credential-free fixture tests (T004) pass: foreach (4 resources, 2 providers, 2 variables), multi-provider (5 providers, locals, 8 outputs), modules (module blocks with literal source/version). Comment key tests (T005) pass. Provider array/object tests (T005) pass.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-17T17:24:21.295038+08:00","updated_at":"2026-02-17T19:00:05.945567+08:00","closed_at":"2026-02-17T19:00:05.945567+08:00","labels":["component:parser","phase:us1","requirement:FR-002","requirement:FR-009","requirement:FR-010","requirement:FR-011","requirement:FR-012","spec:001-tf-json-parsing","story:US1"],"dependencies":[{"issue_id":"oxid-7rb","depends_on_id":"oxid-5jn","type":"parent-child","created_at":"2026-02-17T17:24:21.296639+08:00","created_by":"daemon"},{"issue_id":"oxid-7rb","depends_on_id":"oxid-6gz","type":"blocks","created_at":"2026-02-17T17:25:02.019941+08:00","created_by":"daemon"},{"issue_id":"oxid-7rb","depends_on_id":"oxid-1lw","type":"blocks","created_at":"2026-02-17T17:25:02.118252+08:00","created_by":"daemon"}]}
{"id":"oxid-8u0","title":"Write edge case tests for tf.json parsing","description":"Cover all edge cases defined in spec.md: empty JSON, hidden files, JSONC rejection, and coexisting same-basename files.\n\nDesign:\nFile: tests/tf_json_test.rs (append).\n\nTest 20 - test_parse_empty_json:\n  Content: '{}'\n  Call parse_tf_json(\u0026content, path)\n  Assert: result.is_ok()\n  Assert: workspace has 0 resources, 0 providers, 0 variables, 0 outputs\n  Assert: terraform_settings.is_none()\n\nTest 21 - test_tf_json_ordering:\n  Create tempdir with a.tf.json, b.tf.json, c.tf.json (each with one resource)\n  Call load_workspace\n  Assert: resources appear in alphabetical file order\n\nTest 22 - test_tfvars_json_ignored:\n  Create tempdir with terraform.tfvars.json and main.tf.json\n  Assert: only main.tf.json is parsed (tfvars.json not discovered as tf.json)\n  The .tfvars.json file should not match the .tf.json filter\n\nTest 23 - test_json_only_directory_mode_detection:\n  Create tempdir with ONLY .tf.json files (no .tf files)\n  Call load_workspace\n  Assert: succeeds (does not error with 'No .tf files found')\n  Assert: config mode detected as HCL\n\nTest 24 - test_prefixless_tf_json_ignored:\n  Create tempdir with two files:\n    - .tf.json (no prefix, contains a resource)\n    - main.tf.json (valid, contains a different resource)\n  Call load_workspace(dir.path())\n  Assert: only the resource from main.tf.json appears\n  Assert: the resource from .tf.json does NOT appear\n\nAcceptance Criteria:\nAll edge case tests pass. Empty JSON produces empty workspace. Files processed in alphabetical order. .tfvars.json not confused with .tf.json. JSON-only directories work. Prefix-less .tf.json files are ignored.","design":"File: tests/tf_json_test.rs (append).\n\nTest 20 - test_parse_empty_json:\n  Content: '{}'\n  Call parse_tf_json(\u0026content, path)\n  Assert: result.is_ok()\n  Assert: workspace has 0 resources, 0 providers, 0 variables, 0 outputs\n  Assert: terraform_settings.is_none()\n\nTest 21 - test_tf_json_ordering:\n  Create tempdir with a.tf.json, b.tf.json, c.tf.json (each with one resource)\n  Call load_workspace\n  Assert: resources appear in alphabetical file order\n\nTest 22 - test_tfvars_json_ignored:\n  Create tempdir with terraform.tfvars.json and main.tf.json\n  Assert: only main.tf.json is parsed (tfvars.json not discovered as tf.json)\n  The .tfvars.json file should not match the .tf.json filter\n\nTest 23 - test_json_only_directory_mode_detection:\n  Create tempdir with ONLY .tf.json files (no .tf files)\n  Call load_workspace\n  Assert: succeeds (does not error with 'No .tf files found')\n  Assert: config mode detected as HCL","acceptance_criteria":"All edge case tests pass. Empty JSON produces empty workspace. Files processed in alphabetical order. .tfvars.json not confused with .tf.json. JSON-only directories work.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-02-17T17:28:28.018577+08:00","updated_at":"2026-02-17T19:25:10.774919+08:00","closed_at":"2026-02-17T19:25:10.774919+08:00","labels":["phase:polish","requirement:FR-008","spec:001-tf-json-parsing","test:integration"],"dependencies":[{"issue_id":"oxid-8u0","depends_on_id":"oxid-kzu","type":"parent-child","created_at":"2026-02-17T17:28:28.021134+08:00","created_by":"daemon"}]}
{"id":"oxid-amm","title":"Phase 3: US2 - Mixed HCL and JSON (P2)","description":"Verify and test that .tf and .tf.json files coexist in the same directory with correct merging. May require no new code if parse_directory already handles it.","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-02-17T16:59:24.574163+08:00","updated_at":"2026-02-17T19:24:11.56435+08:00","closed_at":"2026-02-17T19:24:11.56435+08:00","labels":["phase:us2","spec:001-tf-json-parsing","story:US2"],"dependencies":[{"issue_id":"oxid-amm","depends_on_id":"oxid-db0","type":"parent-child","created_at":"2026-02-17T16:59:24.575224+08:00","created_by":"daemon"},{"issue_id":"oxid-amm","depends_on_id":"oxid-5jn","type":"blocks","created_at":"2026-02-17T16:59:45.95894+08:00","created_by":"daemon"}]}
{"id":"oxid-db0","title":"Native tf.json Parsing","description":"Add native parsing of *.tf.json (Terraform JSON Configuration Syntax) to Oxid's core config pipeline. Converts JSON → hcl::Body → reuses existing parse_hcl block parser. Unlocks CDKTF, Pulumi, and code-generator workflows.","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-02-17T16:58:19.953995+08:00","updated_at":"2026-02-17T19:26:06.711502+08:00","closed_at":"2026-02-17T19:26:06.711502+08:00","labels":["component:config-loader","component:hcl-parser","spec:001-tf-json-parsing"]}
{"id":"oxid-drb","title":"Write tests for mixed .tf + .tf.json directory parsing","description":"TDD: Write tests verifying that .tf and .tf.json files coexist in the same directory and merge correctly into a single WorkspaceConfig. This validates FR-004 and the core US2 acceptance scenarios.","design":"File: tests/tf_json_test.rs (append).\n\nTest 12 - test_parse_mixed_tf_and_json:\n  Create a tempdir (use tempfile::TempDir following state_test.rs pattern)\n  Write providers.tf (HCL): terraform { required_providers { random = { source = \"hashicorp/random\" } } } provider \"random\" {}\n  Write resources.tf.json (JSON): {\"resource\": {\"random_pet\": {\"from_json\": {\"length\": 2}}}}\n  Call load_workspace(dir.path())\n  Assert: 1 provider (random)\n  Assert: 1 resource (random_pet.from_json)\n  Assert: terraform_settings present with required_providers\n  This proves cross-format merging works\n\nTest 13 - test_mixed_variable_cross_reference:\n  Create tempdir\n  Write vars.tf (HCL): variable \"env\" { default = \"prod\" }\n  Write main.tf.json (JSON): {\"resource\": {\"null_resource\": {\"test\": {\"triggers\": {\"env\": \"${var.env}\"}}}}}\n  Call load_workspace(dir.path())\n  Assert: 1 variable (env) and 1 resource (null_resource.test)\n  Assert: resource has triggers with expression referencing var.env\n\nTest 14 - test_mixed_both_tf_and_tf_json_same_basename:\n  Create tempdir with main.tf and main.tf.json (different resources in each)\n  Assert: resources from BOTH files appear in workspace (merged, not overwritten)\n  This validates the edge case from spec","acceptance_criteria":"All mixed-directory tests pass. Resources from both .tf and .tf.json files appear in the merged WorkspaceConfig. Cross-format variable references work. Same-basename files are both parsed.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-17T17:26:11.627994+08:00","updated_at":"2026-02-17T19:23:47.194915+08:00","closed_at":"2026-02-17T19:23:47.194915+08:00","labels":["phase:us2","requirement:FR-004","spec:001-tf-json-parsing","story:US2","test:integration"],"dependencies":[{"issue_id":"oxid-drb","depends_on_id":"oxid-amm","type":"parent-child","created_at":"2026-02-17T17:26:11.630231+08:00","created_by":"daemon"}]}
{"id":"oxid-e53","title":"Verify existing HCL tests pass after parse_hcl refactor","description":"Run the full existing test suite (cargo test) to confirm the parse_hcl refactoring introduced no regressions. This is the gate that proves the extraction was safe.","design":"Run: cargo test --all. Check that config_test, dag_test, executor_test, integration_test, state_test all pass. Also run cargo clippy --all-targets -- -D warnings and cargo fmt --all -- --check.","acceptance_criteria":"cargo test passes (all existing tests green). cargo clippy passes with no warnings. cargo fmt check passes.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-17T17:14:12.954383+08:00","updated_at":"2026-02-17T18:52:02.173257+08:00","closed_at":"2026-02-17T18:52:02.173257+08:00","labels":["phase:foundational","spec:001-tf-json-parsing","test:regression"],"dependencies":[{"issue_id":"oxid-e53","depends_on_id":"oxid-4j7","type":"parent-child","created_at":"2026-02-17T17:14:12.955607+08:00","created_by":"daemon"},{"issue_id":"oxid-e53","depends_on_id":"oxid-1lw","type":"blocks","created_at":"2026-02-17T17:14:32.695754+08:00","created_by":"daemon"}]}
{"id":"oxid-ec8","title":"Run quality gates: clippy, rustfmt, full test suite","description":"Final verification that all code passes CI quality gates and no regressions were introduced in existing tests.","design":"Run in order:\n1. cargo fmt --all -- --check (must pass with no formatting issues)\n2. cargo clippy --all-targets -- -D warnings (must pass with no warnings)\n3. cargo test (full suite - all existing tests + all new tf_json tests must pass)\n4. Verify test count: all new tests in tf_json_test.rs are discovered and run\n5. Check for any TODO or unimplemented!() left in json_parser.rs","acceptance_criteria":"cargo fmt passes. cargo clippy passes with zero warnings. cargo test passes with all tests green. No TODO/unimplemented markers remain in production code.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-02-17T17:28:28.135365+08:00","updated_at":"2026-02-17T19:26:06.546849+08:00","closed_at":"2026-02-17T19:26:06.546849+08:00","labels":["phase:polish","spec:001-tf-json-parsing","test:regression"],"dependencies":[{"issue_id":"oxid-ec8","depends_on_id":"oxid-kzu","type":"parent-child","created_at":"2026-02-17T17:28:28.137416+08:00","created_by":"daemon"},{"issue_id":"oxid-ec8","depends_on_id":"oxid-8u0","type":"blocks","created_at":"2026-02-17T17:28:36.106162+08:00","created_by":"daemon"}]}
{"id":"oxid-ia7","title":"Write integration tests for credential-free CDKTF fixtures","description":"TDD: Write tests BEFORE implementation. These tests parse the 3 credential-free CDKTF fixtures (foreach, multi-provider, modules) and assert the resulting WorkspaceConfig is correct. Tests should initially fail because json_parser is a stub.","design":"File: tests/tf_json_test.rs (NEW). Follow existing test patterns: use oxid::hcl::json_parser::parse_tf_json; use std::path::Path;\n\nTest 1 - test_parse_tf_json_foreach:\n  Fixture: tests/fixtures/tf-json/foreach/cdk.tf.json\n  Read file content with std::fs::read_to_string\n  Call parse_tf_json(\u0026content, \u0026path)\n  Assert: 4 resources (null_resource.triggered, random_integer.region_seeds, random_pet.env_names, random_string.service_tokens)\n  Assert: 2 providers (null, random)\n  Assert: 2 variables (environments with type list(string), services with type map)\n  Assert: terraform_settings.is_some() with required_providers containing null and random\n  Assert: resources have for_each expressions (string containing toset or map object)\n\nTest 2 - test_parse_tf_json_multi_provider:\n  Fixture: tests/fixtures/tf-json/multi-provider/cdk.tf.json\n  Assert: 5 providers (local, null, random, time, tls)\n  Assert: locals block has common_tags (map with interpolation) and environments (list)\n  Assert: 8 outputs with interpolation expressions like ${random_pet.project_name_pet.id}\n  Assert: multiple resources across provider types (local_file, null_resource, random_*, time_static, tls_*)\n  Assert: depends_on arrays present on some resources\n\nTest 3 - test_parse_tf_json_modules:\n  Fixture: tests/fixtures/tf-json/modules/cdk.tf.json\n  Assert: module blocks present with source as literal string (not template-parsed)\n  Assert: module.version is literal string\n  Assert: module input variables with interpolation expressions","acceptance_criteria":"Tests compile and are runnable via cargo test tf_json. Initially FAIL with 'not implemented' error from parse_tf_json stub. After T007 implementation, all 3 tests pass.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-17T17:21:26.70501+08:00","updated_at":"2026-02-17T19:00:06.022542+08:00","closed_at":"2026-02-17T19:00:06.022542+08:00","labels":["phase:us1","requirement:FR-002","requirement:FR-009","requirement:FR-010","requirement:FR-012","spec:001-tf-json-parsing","story:US1","test:integration"],"dependencies":[{"issue_id":"oxid-ia7","depends_on_id":"oxid-5jn","type":"parent-child","created_at":"2026-02-17T17:21:26.70632+08:00","created_by":"daemon"},{"issue_id":"oxid-ia7","depends_on_id":"oxid-6gz","type":"blocks","created_at":"2026-02-17T17:21:34.20408+08:00","created_by":"daemon"}]}
{"id":"oxid-k2j","title":"Fix scalar type coercion in coerce_value_to_cty_type","description":"","status":"open","priority":2,"issue_type":"bug","created_at":"2026-02-18T08:54:17.376845+08:00","updated_at":"2026-02-18T08:54:17.376845+08:00"}
{"id":"oxid-kzu","title":"Phase 5: Polish \u0026 Edge Cases","description":"Edge case coverage, quality gates, regression verification. Ensures the feature is production-ready.","status":"closed","priority":3,"issue_type":"feature","created_at":"2026-02-17T16:59:24.892217+08:00","updated_at":"2026-02-17T19:26:06.630089+08:00","closed_at":"2026-02-17T19:26:06.630089+08:00","labels":["phase:polish","spec:001-tf-json-parsing"],"dependencies":[{"issue_id":"oxid-kzu","depends_on_id":"oxid-db0","type":"parent-child","created_at":"2026-02-17T16:59:24.893201+08:00","created_by":"daemon"},{"issue_id":"oxid-kzu","depends_on_id":"oxid-amm","type":"blocks","created_at":"2026-02-17T16:59:46.204715+08:00","created_by":"daemon"},{"issue_id":"oxid-kzu","depends_on_id":"oxid-lab","type":"blocks","created_at":"2026-02-17T16:59:46.322575+08:00","created_by":"daemon"}]}
{"id":"oxid-lab","title":"Phase 4: US3 - Clear Error Messages (P3)","description":"Ensure malformed .tf.json files produce error messages that include the filename and a human-readable description. Critical for developer experience.","status":"closed","priority":2,"issue_type":"feature","created_at":"2026-02-17T16:59:24.732223+08:00","updated_at":"2026-02-17T19:24:11.647771+08:00","closed_at":"2026-02-17T19:24:11.647771+08:00","labels":["phase:us3","spec:001-tf-json-parsing","story:US3"],"dependencies":[{"issue_id":"oxid-lab","depends_on_id":"oxid-db0","type":"parent-child","created_at":"2026-02-17T16:59:24.733752+08:00","created_by":"daemon"},{"issue_id":"oxid-lab","depends_on_id":"oxid-5jn","type":"blocks","created_at":"2026-02-17T16:59:46.079394+08:00","created_by":"daemon"}]}
{"id":"oxid-p4r","title":"Write error handling tests for malformed .tf.json files","description":"TDD: Write tests for all 3 US3 acceptance scenarios plus error edge cases. Errors must include the filename and a clear description.","design":"File: tests/tf_json_test.rs (append). Follow existing error test patterns from config_test.rs: assert\\!(result.is_err()) and result.unwrap_err().to_string().contains(expected_substring).\n\nTest 15 - test_parse_invalid_json_syntax:\n  Inline JSON with trailing comma: r#\"{\"resource\": {\"null_resource\": {\"test\": {},}}}\"#\n  Call parse_tf_json(\u0026content, Path::new(\"broken.tf.json\"))\n  Assert: result.is_err()\n  Assert: error message contains 'broken.tf.json'\n  Assert: error message contains some indication of JSON syntax error\n\nTest 16 - test_parse_invalid_structure:\n  Valid JSON but invalid Terraform structure: {\"not_a_block_type\": {\"foo\": \"bar\"}}\n  Call parse_tf_json\n  Assert: result.is_err() OR parsed with no resources (depending on how unknown keys are handled)\n  If error: assert error contains filename\n\nTest 17 - test_parse_non_object_root:\n  JSON array at root: [1, 2, 3]\n  Assert: result.is_err()\n  Assert: error message indicates root must be an object\n\nTest 18 - test_error_preserves_filename:\n  Use various error scenarios\n  Assert: every error message contains the file path passed to parse_tf_json\n  This is the core FR-007 validation\n\nTest 19 - test_strict_json_only:\n  JSONC with comment (// comment): assert error (FR-008)\n  JSON5 with single quotes: assert error (FR-008)\n  Both should fail at serde_json::from_str level with clear error","acceptance_criteria":"All error tests pass. Every error message includes the filename. JSON syntax errors, structural errors, and non-object roots all produce clear, descriptive error messages.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-17T17:27:50.653991+08:00","updated_at":"2026-02-17T19:23:47.277202+08:00","closed_at":"2026-02-17T19:23:47.277202+08:00","labels":["phase:us3","requirement:FR-007","requirement:FR-008","spec:001-tf-json-parsing","story:US3","test:integration"],"dependencies":[{"issue_id":"oxid-p4r","depends_on_id":"oxid-lab","type":"parent-child","created_at":"2026-02-17T17:27:50.656327+08:00","created_by":"daemon"}]}
{"id":"oxid-pwn","title":"Write parsing tests for AWS CDKTF fixtures","description":"Parse the 5 AWS-provider CDKTF fixtures to verify complex real-world tf.json structures parse correctly. No AWS credentials needed — these are parse-only tests validating WorkspaceConfig structure.","design":"File: tests/tf_json_test.rs (append).\n\nTest 7 - test_parse_tf_json_iam_grants:\n  Fixture: tests/fixtures/tf-json/iam-grants/cdk.tf.json\n  Assert: data_sources present (aws_caller_identity, aws_iam_policy_document)\n  Assert: resources include IAM roles, policies\n  Assert: cross-resource references present (expressions containing ${aws_iam_role...})\n  Assert: provider is 'aws'\n\nTest 8 - test_parse_tf_json_encryption:\n  Fixture: tests/fixtures/tf-json/encryption/cdk.tf.json\n  Assert: data sources present\n  Assert: KMS-related resources present\n  Assert: outputs contain interpolation expressions\n\nTest 9 - test_parse_tf_json_compute_events:\n  Fixture: tests/fixtures/tf-json/compute-events/cdk.tf.json\n  Assert: data sources present (archive_file)\n  Assert: Lambda and SQS resources\n  Assert: depends_on arrays on some resources (plain strings, no ${})\n\nTest 10 - test_parse_tf_json_storage_autoscaling:\n  Fixture: tests/fixtures/tf-json/storage-autoscaling/cdk.tf.json\n  Assert: DynamoDB and autoscaling resources\n  Assert: multiple resource types present\n\nTest 11 - test_parse_tf_json_stepfunctions:\n  Fixture: tests/fixtures/tf-json/stepfunctions/cdk.tf.json\n  Assert: Step Functions state machine resource present\n  Assert: Embedded JSON definition string (literal, not template-parsed)\n  Assert: Long depends_on arrays\n\nPattern: Each test reads fixture file, calls parse_tf_json, verifies resource counts, provider names, data source presence. Use assert! and assert_eq! following existing config_test.rs patterns.","acceptance_criteria":"All 5 AWS fixture tests pass. Each fixture parses without errors. WorkspaceConfig contains expected resource types, data sources, providers, and outputs for each fixture.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-17T17:24:21.541518+08:00","updated_at":"2026-02-17T19:23:47.116547+08:00","closed_at":"2026-02-17T19:23:47.116547+08:00","labels":["phase:us1","requirement:FR-002","spec:001-tf-json-parsing","story:US1","test:integration"],"dependencies":[{"issue_id":"oxid-pwn","depends_on_id":"oxid-5jn","type":"parent-child","created_at":"2026-02-17T17:24:21.544571+08:00","created_by":"daemon"},{"issue_id":"oxid-pwn","depends_on_id":"oxid-7rb","type":"blocks","created_at":"2026-02-17T17:25:02.288596+08:00","created_by":"daemon"}]}
{"id":"oxid-qnz","title":"Verify mixed .tf + .tf.json merge behavior","description":"Confirm that parse_directory in hcl/mod.rs correctly handles mixed directories. If T007 (file discovery) already handles this via separate collection+merge, this task verifies correctness. May require no additional code.","design":"Verify that parse_directory() in src/hcl/mod.rs: (1) collects .tf files first, parses them, merges into workspace, (2) then collects .tf.json files, parses them, merges into same workspace. The existing merge_workspace() handles all field merging. Test with T009 test suite. If tests pass without changes, mark this task as done with note 'no-op - merge behavior verified'.","acceptance_criteria":"Mixed directory tests (T009) all pass. load_workspace on a directory with both .tf and .tf.json files returns a WorkspaceConfig containing resources from both formats.","status":"closed","priority":2,"issue_type":"task","created_at":"2026-02-17T17:26:11.752398+08:00","updated_at":"2026-02-17T19:24:11.388651+08:00","closed_at":"2026-02-17T19:24:11.388651+08:00","labels":["component:parser","phase:us2","requirement:FR-004","spec:001-tf-json-parsing","story:US2"],"dependencies":[{"issue_id":"oxid-qnz","depends_on_id":"oxid-amm","type":"parent-child","created_at":"2026-02-17T17:26:11.754129+08:00","created_by":"daemon"},{"issue_id":"oxid-qnz","depends_on_id":"oxid-drb","type":"blocks","created_at":"2026-02-17T17:27:09.313135+08:00","created_by":"daemon"}]}
{"id":"oxid-wbl","title":"Write tests for comment key stripping and provider array form","description":"TDD: Write targeted tests for FR-010 (comment keys), FR-012 (array/object provider forms), FR-009 (single-interpolation unwrapping), FR-011 (literal context rules), and FR-011 (depends_on literals). These validate specific JSON parsing behaviors that CDKTF relies on.\n\nDesign:\nFile: tests/tf_json_test.rs (append to same file as T004).\n\nTest 4 - test_comment_keys_ignored:\n  Use inline JSON string r#\"{...}\"# with '//' keys at root and resource level\n  Parse with parse_tf_json\n  Assert: no resource or attribute contains '//' as a key\n  Assert: actual resources are present (comment keys did not break parsing)\n  Verify against foreach fixture which has '//' on every resource\n\nTest 5 - test_provider_array_form:\n  Use inline JSON with provider as array: {\"provider\": {\"random\": [{}]}}\n  Parse and assert: 1 provider named 'random'\n  Use inline JSON with provider as object: {\"provider\": {\"random\": {}}}\n  Parse and assert: 1 provider named 'random'\n  Both forms produce identical WorkspaceConfig\n\nTest 6 - test_provider_multiple_configs:\n  Inline JSON with provider array having 2 elements (e.g., aws with alias):\n  {\"provider\": {\"aws\": [{\"region\": \"us-east-1\"}, {\"alias\": \"west\", \"region\": \"us-west-1\"}]}}\n  Assert: 2 provider configs for 'aws'\n\nTest 6a - test_single_interpolation_unwrapping:\n  Validates FR-009: a string containing only a single ${...} interpolation returns the raw typed value, not a string template. This behavior is handled downstream by hcl_expr_to_expression in parser.rs but is validated end-to-end through parse_tf_json.\n  Inline JSON resource with single-interpolation attribute: {\"resource\": {\"null_resource\": {\"test\": {\"value\": \"${var.count}\"}}}}\n  Parse with parse_tf_json\n  Assert: the expression for \"value\" is a variable reference (not wrapped in a string template)\n  Inline JSON resource with multi-interpolation: {\"resource\": {\"null_resource\": {\"test2\": {\"value\": \"prefix-${var.name}-suffix\"}}}}\n  Parse and assert: the expression IS a string template containing an interpolation (not unwrapped)\n\nTest 6b - test_literal_context_not_template_parsed:\n  Validates FR-011: certain block attributes are literal strings and must NOT be template-parsed even if they contain ${...}-like content. Behavior handled by existing parser.rs logic; validated end-to-end through parse_tf_json.\n  Inline JSON with:\n    - variable with type: \"list(string)\" and description: \"My ${not_a_ref} desc\"\n    - module with source: \"hashicorp/consul/aws\" and version: \"0.1.0\"\n    - terraform block with required_version: \"\u003e= 1.0\"\n  Assert: variable.type is literal \"list(string)\" (no expression parsing)\n  Assert: variable.description is literal string (\"${not_a_ref}\" NOT treated as interpolation)\n  Assert: module.source is literal string \"hashicorp/consul/aws\"\n  Assert: module.version is literal string \"0.1.0\"\n  Assert: terraform.required_version is literal string \"\u003e= 1.0\"\n\nTest 6c - test_depends_on_literal_strings:\n  Validates FR-011: depends_on values are resource address strings, not expression templates. Values must NOT be wrapped in ${...} or parsed as interpolation.\n  Inline JSON: {\"resource\": {\"null_resource\": {\"test\": {\"depends_on\": [\"aws_vpc.main\", \"aws_subnet.primary\"]}}}}\n  Parse with parse_tf_json\n  Assert: depends_on contains exactly [\"aws_vpc.main\", \"aws_subnet.primary\"]\n  Assert: values are plain strings (not variable references or expression templates)\n  Also test that depends_on values containing dots are treated as resource addresses, not attribute access expressions\n\nAcceptance Criteria:\nTests compile. Initially fail. After T007, all pass. Comment keys are never present in parsed WorkspaceConfig. Both array and object provider forms produce correct results. Single-interpolation strings are unwrapped to raw expressions; multi-interpolation strings remain as templates. Literal context attributes (variable.type, variable.description, module.source, module.version, terraform.*) are never template-parsed. depends_on values are plain resource address strings, never expression templates.","design":"File: tests/tf_json_test.rs (append to same file as T004).\n\nTest 4 - test_comment_keys_ignored:\n  Use inline JSON string r#\"{...}\"# with '//' keys at root and resource level\n  Parse with parse_tf_json\n  Assert: no resource or attribute contains '//' as a key\n  Assert: actual resources are present (comment keys didn't break parsing)\n  Verify against foreach fixture which has '//' on every resource\n\nTest 5 - test_provider_array_form:\n  Use inline JSON with provider as array: {\"provider\": {\"random\": [{}]}}\n  Parse and assert: 1 provider named 'random'\n  Use inline JSON with provider as object: {\"provider\": {\"random\": {}}}\n  Parse and assert: 1 provider named 'random'\n  Both forms produce identical WorkspaceConfig\n\nTest 6 - test_provider_multiple_configs:\n  Inline JSON with provider array having 2 elements (e.g., aws with alias):\n  {\"provider\": {\"aws\": [{\"region\": \"us-east-1\"}, {\"alias\": \"west\", \"region\": \"us-west-1\"}]}}\n  Assert: 2 provider configs for 'aws'","acceptance_criteria":"Tests compile. Initially fail. After T007, all pass. Comment keys are never present in parsed WorkspaceConfig. Both array and object provider forms produce correct results.","status":"closed","priority":1,"issue_type":"task","created_at":"2026-02-17T17:21:26.8263+08:00","updated_at":"2026-02-17T19:00:06.105203+08:00","closed_at":"2026-02-17T19:00:06.105203+08:00","labels":["phase:us1","requirement:FR-010","requirement:FR-012","spec:001-tf-json-parsing","story:US1","test:integration"],"dependencies":[{"issue_id":"oxid-wbl","depends_on_id":"oxid-5jn","type":"parent-child","created_at":"2026-02-17T17:21:26.82756+08:00","created_by":"daemon"},{"issue_id":"oxid-wbl","depends_on_id":"oxid-6gz","type":"blocks","created_at":"2026-02-17T17:21:34.283983+08:00","created_by":"daemon"}]}
